{
  "feature_id": "otc.kanban.multiview.offers+escrow+finalize",
  "goal": "Kanban en tiempo real con estados por usuario OTC: cuando un CLIENTE crea una transacción queda 'pending' visible para todos los usuarios OTC. Cada OTC puede ofertar (sin cambiar el estado global). Para quien ofertó, la tarjeta aparece en su columna 'Con mi oferta' pero sigue 'Pendiente' para los demás. El CLIENTE acepta una sola oferta: solo para el ganador pasa a 'Escrow creado'; para los demás desaparece del Kanban y queda como 'perdida' en el historial. Al subir prueba (en CTF) y validarlo el cliente, mover a 'Operación finalizada' (4ta columna).",
  "columns_ui_for_otc": [
    { "key": "pending", "title": "Pendientes" },
    { "key": "offered_by_me", "title": "Con mi oferta" },
    { "key": "escrow", "title": "Escrow creado" },
    { "key": "completed", "title": "Operación finalizada" }
  ],
  "invariants": [
    "El estado global de la transacción (tx.status) es minimal: 'pending' | 'escrow' | 'completed' | 'failed'.",
    "Las columnas 1-3 son vistas por-usuario (derivadas) excepto 'completed' que es global.",
    "Filtros existentes por tipo (Fiat→Crypto | Crypto→Fiat | Todas) y por fecha siguen activos."
  ],
  "auth_model_min": {
    "headers": [
      "x-user-id: string (obligatorio)",
      "x-role: 'client' | 'otc' (obligatorio)",
      "x-api-key / x-signature: como definido previamente (opcional si ya implementado)"
    ]
  },
  "data_structures": {
    "Transaction": {
      "id": "string",
      "type": "'fiat_to_crypto' | 'crypto_to_fiat'",
      "clientId": "string",
      "status": "'pending' | 'escrow' | 'completed' | 'failed'",
      "winnerOtcId": "string | null",
      "createdAt": "ISO string",
      "metadata": "object",
      "proofUploaded": "boolean (solo aplica CTF)"
    },
    "Offer": {
      "id": "string",
      "txId": "string",
      "otcUserId": "string",
      "amount": "number",
      "createdAt": "ISO string",
      "status": "'open' | 'won' | 'lost'"
    }
  },
  "api_contract": {
    "create_tx": {
      "method": "POST",
      "path": "/sim/tx",
      "role": "client",
      "body": { "amount": "number>0", "currency": "ISO4217", "type": "fiat_to_crypto|crypto_to_fiat", "metadata": "object?" },
      "result": "tx(status='pending') visible para OTC"
    },
    "list_tx_for_otc": {
      "method": "GET",
      "path": "/api/transactions",
      "role": "otc",
      "query": [
        "type=all|fiat_to_crypto|crypto_to_fiat",
        "datePreset=today|this_week|this_month|range",
        "from=YYYY-MM-DD (si range)",
        "to=YYYY-MM-DD (si range)",
        "view=kanban|history (kanban excluye 'lost')"
      ],
      "response": {
        "items": [
          {
            "id": "string",
            "statusGlobal": "pending|escrow|completed|failed",
            "kanbanView": "pending|offered_by_me|escrow|completed",
            "type": "fiat_to_crypto|crypto_to_fiat",
            "createdAt": "ISO",
            "meta": "object"
          }
        ]
      }
    },
    "make_offer": {
      "method": "POST",
      "path": "/api/tx/:id/offer",
      "role": "otc",
      "body": { "amount": "number>0" },
      "effect": "crea Offer(status='open'); el emisor verá la tx en 'Con mi oferta' (kanbanView=offered_by_me) sin afectar a otros"
    },
    "accept_offer": {
      "method": "POST",
      "path": "/api/tx/:id/accept",
      "role": "client",
      "body": { "offerId": "string" },
      "effect": "tx.status='escrow', tx.winnerOtcId=set; esa Offer->'won'; demás Offers->'lost'; broadcast sse 'tx.accepted'"
    },
    "upload_proof_ctf": {
      "method": "POST",
      "path": "/api/tx/:id/proof",
      "role": "otc (solo ganador)",
      "body": { "fileName": "string", "hash": "string (sha256 de archivo simulado)" },
      "effect": "marca tx.proofUploaded=true (solo si type='crypto_to_fiat')"
    },
    "validate_and_finalize": {
      "method": "POST",
      "path": "/api/tx/:id/validate",
      "role": "client",
      "effect": "si (type=CTF && proofUploaded) || (type=FTC) -> tx.status='completed'; broadcast 'tx.completed'"
    }
  },
  "sse_events": [
    { "event": "tx.created", "payload": "{tx}" },
    { "event": "offer.created", "payload": "{offer}" },
    { "event": "tx.accepted", "payload": "{txId, winnerOtcId}" },
    { "event": "tx.completed", "payload": "{txId}" }
  ],
  "server_patch": {
    "file": "index.js",
    "summary": "Extiende el simulador previo: roles mínimos, ofertas, aceptación (escrow), prueba CTF, finalización, y vistas por-usuario.",
    "insertions": [
      "// ===== ROLES MIN =====",
      "function requireUser(req,res){",
      "  const userId = (req.headers['x-user-id']||'').toString();",
      "  const role = (req.headers['x-role']||'').toString();",
      "  if(!userId || !role) return res.status(401).json({error:'unauthorized_user'});",
      "  req.user = { id:userId, role };",
      "}",
      "",
      "// ===== STORES ===== (en memoria, ligeros)",
      "const offersByTx = new Map(); // txId -> Offer[]",
      "",
      "// helper",
      "function newId(p){ return p + crypto.randomBytes(6).toString('hex'); }",
      "",
      "// wrapper auth existente",
      "function requireAll(req,res){",
      "  const a = requireAuth(req,res); if(a) return true;",
      "  const b = requireUser(req,res); if(b) return true;",
      "  return false;",
      "}",
      "",
      "// ===== OFERTAR =====",
      "app.post('/api/tx/:id/offer', (req,res)=>{",
      "  if(requireAll(req,res)) return;",
      "  if(req.user.role!=='otc') return res.status(403).json({error:'forbidden'});",
      "  const tx = store.get(req.params.id);",
      "  if(!tx) return res.status(404).json({error:'not_found'});",
      "  if(tx.status!=='pending') return res.status(409).json({error:'not_pending'});",
      "  const amount = Number(req.body?.amount||0);",
      "  if(!(amount>0)) return res.status(400).json({error:'bad_amount'});",
      "  const list = offersByTx.get(tx.id)||[];",
      "  // evitar ofertas duplicadas del mismo usuario",
      "  if(list.some(o=>o.otcUserId===req.user.id && o.status==='open')){",
      "    return res.status(409).json({error:'already_offered'});",
      "  }",
      "  const offer = { id:newId('off_'), txId:tx.id, otcUserId:req.user.id, amount, createdAt:new Date().toISOString(), status:'open' };",
      "  list.push(offer); offersByTx.set(tx.id, list);",
      "  broadcast('offer.created', offer);",
      "  res.json(offer);",
      "});",
      "",
      "// ===== ACEPTAR OFERTA (CLIENTE) -> ESCROW =====",
      "app.post('/api/tx/:id/accept', (req,res)=>{",
      "  if(requireAll(req,res)) return;",
      "  if(req.user.role!=='client') return res.status(403).json({error:'forbidden'});",
      "  const tx = store.get(req.params.id);",
      "  if(!tx) return res.status(404).json({error:'not_found'});",
      "  if(tx.clientId && tx.clientId!==req.user.id) return res.status(403).json({error:'not_owner'});",
      "  if(tx.status!=='pending') return res.status(409).json({error:'not_pending'});",
      "  const offerId = req.body?.offerId;",
      "  const list = offersByTx.get(tx.id)||[];",
      "  const chosen = list.find(o=>o.id===offerId && o.status==='open');",
      "  if(!chosen) return res.status(404).json({error:'offer_not_found'});",
      "  // cerrar ofertas",
      "  for(const o of list){ o.status = (o.id===offerId) ? 'won' : 'lost'; }",
      "  tx.status = 'escrow';",
      "  tx.winnerOtcId = chosen.otcUserId;",
      "  broadcast('tx.accepted', { txId: tx.id, winnerOtcId: tx.winnerOtcId });",
      "  res.json(txResponse(tx));",
      "});",
      "",
      "// ===== SUBIR PRUEBA (CTF) =====",
      "app.post('/api/tx/:id/proof', (req,res)=>{",
      "  if(requireAll(req,res)) return;",
      "  const tx = store.get(req.params.id);",
      "  if(!tx) return res.status(404).json({error:'not_found'});",
      "  if(tx.type!=='crypto_to_fiat') return res.status(400).json({error:'not_ctf'});",
      "  if(tx.status!=='escrow') return res.status(409).json({error:'not_escrow'});",
      "  if(req.user.role!=='otc' || req.user.id!==tx.winnerOtcId) return res.status(403).json({error:'forbidden'});",
      "  const ok = (req.body?.fileName && req.body?.hash);",
      "  if(!ok) return res.status(400).json({error:'bad_proof'});",
      "  tx.proofUploaded = true;",
      "  res.json({ok:true});",
      "});",
      "",
      "// ===== VALIDAR Y FINALIZAR =====",
      "app.post('/api/tx/:id/validate', (req,res)=>{",
      "  if(requireAll(req,res)) return;",
      "  if(req.user.role!=='client') return res.status(403).json({error:'forbidden'});",
      "  const tx = store.get(req.params.id);",
      "  if(!tx) return res.status(404).json({error:'not_found'});",
      "  if(tx.clientId && tx.clientId!==req.user.id) return res.status(403).json({error:'not_owner'});",
      "  if(tx.status!=='escrow') return res.status(409).json({error:'not_escrow'});",
      "  if(tx.type==='crypto_to_fiat' && !tx.proofUploaded) return res.status(409).json({error:'proof_required'});",
      "  tx.status = 'completed';",
      "  broadcast('tx.completed', { txId: tx.id });",
      "  res.json(txResponse(tx));",
      "});",
      "",
      "// ===== LISTAR PARA OTC (con vistas por-usuario) =====",
      "app.get('/api/transactions', (req,res)=>{",
      "  if(requireAll(req,res)) return;",
      "  if(req.user.role!=='otc') return res.status(403).json({error:'forbidden'});",
      "  const type = (req.query.type||'all').toString();",
      "  const preset = (req.query.datePreset||'today').toString();",
      "  const from = req.query.from ? new Date(req.query.from.toString()) : null;",
      "  const to = req.query.to ? new Date(req.query.to.toString()+'T23:59:59') : null;",
      "  const view = (req.query.view||'kanban').toString();",
      "  const now = new Date();",
      "  const startOfToday = new Date(now); startOfToday.setHours(0,0,0,0);",
      "  const startOfWeek = new Date(now); startOfWeek.setDate(now.getDate()-((now.getDay()+6)%7)); startOfWeek.setHours(0,0,0,0);",
      "  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);",
      "",
      "  function passDate(d){",
      "    if(preset==='today') return d>=startOfToday;",
      "    if(preset==='this_week') return d>=startOfWeek;",
      "    if(preset==='this_month') return d>=startOfMonth;",
      "    if(preset==='range') return (!!from && d>=from) && (!!to && d<=to);",
      "    return true;",
      "  }",
      "",
      "  const items = [];",
      "  for(const tx of store.values()){",
      "    if(type!=='all' && tx.type!==type) continue;",
      "    const d = new Date(tx.createdAt);",
      "    if(!passDate(d)) continue;",
      "    // Derivar vista por usuario OTC solicitante",
      "    const offers = offersByTx.get(tx.id)||[];",
      "    const myOffer = offers.find(o=>o.otcUserId===req.user.id);",
      "    let kanbanView = 'pending';",
      "    if(tx.status==='completed') kanbanView = 'completed';",
      "    else if(tx.status==='escrow'){",
      "      kanbanView = (tx.winnerOtcId===req.user.id) ? 'escrow' : 'lost';",
      "    } else if(tx.status==='pending'){",
      "      if(myOffer) kanbanView = 'offered_by_me';",
      "    }",
      "    if(view==='kanban' && kanbanView==='lost') continue; // ocultar perdidas en kanban",
      "    items.push({",
      "      id: tx.id,",
      "      statusGlobal: tx.status,",
      "      kanbanView,",
      "      type: tx.type,",
      "      createdAt: tx.createdAt,",
      "      meta: tx.metadata||{}",
      "    });",
      "  }",
      "  res.json({items});",
      "});",
      "",
      "// ===== CREAR TX (override para CLIENTE con clientId) =====",
      "const originalCreate = app._router.stack.find(l=>l.route && l.route.path==='/sim/tx' && l.route.methods.post);",
      "/* Si no quieres meterte con la capa interna de Express, puedes reemplazar directamente tu handler previo de POST /sim/tx \n   para setear clientId y status='pending' asegurando compatibilidad. A continuación un handler directo: */",
      "app.post('/sim/tx', (req,res)=>{",
      "  const authErr = requireAuth(req,res); if(authErr) return;",
      "  const u = requireUser(req,res); if(u) return;",
      "  if(req.user.role!=='client') return res.status(403).json({error:'forbidden'});",
      "  const body = req.body||{};",
      "  const errs = validateCreate(body);",
      "  if(errs.length) return res.status(400).json({error:'bad_request', details:errs});",
      "  const id = 'tx_' + crypto.randomBytes(8).toString('hex');",
      "  const now = new Date().toISOString();",
      "  const tx = {",
      "    id,",
      "    clientId: req.user.id,",
      "    type: body.type || 'fiat_to_crypto',",
      "    amount: body.amount,",
      "    currency: body.currency || 'USD',",
      "    metadata: body.metadata || {},",
      "    status: 'pending',",
      "    winnerOtcId: null,",
      "    proofUploaded: false,",
      "    createdAt: now",
      "  };",
      "  store.set(id, tx);",
      "  broadcast('tx.created', txResponse(tx));",
      "  res.json(txResponse(tx));",
      "});"
    ]
  },
  "client_patch": {
    "file": "src/pages/Kanban.tsx",
    "summary": "Mapear kanbanView -> columnas. Mantener filtros type/date. SSE ya implementado; extender manejo para accepted/completed.",
    "insertions": [
      "type KanbanView = 'pending'|'offered_by_me'|'escrow'|'completed'|'lost';",
      "type TxItem = { id:string; statusGlobal:'pending'|'escrow'|'completed'|'failed'; kanbanView:KanbanView; type:'fiat_to_crypto'|'crypto_to_fiat'; createdAt:string; meta:any };",
      "const COLS = [",
      "  { key:'pending', title:'Pendientes' },",
      "  { key:'offered_by_me', title:'Con mi oferta' },",
      "  { key:'escrow', title:'Escrow creado' },",
      "  { key:'completed', title:'Operación finalizada' }",
      "] as const;"
    ],
    "fetch": [
      "async function fetchData(){",
      "  setLoading(true);",
      "  try{",
      "    const q = new URLSearchParams(buildQuery());",
      "    q.set('view','kanban');",
      "    const res = await fetch(`/api/transactions?${q.toString()}`, { headers: { 'x-user-id': userId, 'x-role': 'otc' } as any });",
      "    const data = await res.json();",
      "    const arr: TxItem[] = data.items || [];",
      "    setItems(arr);",
      "  } finally { setLoading(false); }",
      "}"
    ],
    "sse": [
      "// Reusar EventSource existente",
      "es.addEventListener('tx.created', (e:any)=>{ const tx = JSON.parse(e.data); maybeUpsertFromEvent(tx); });",
      "es.addEventListener('tx.accepted', (e:any)=>{",
      "  const {txId, winnerOtcId} = JSON.parse(e.data);",
      "  setItems(prev=>{",
      "    const idx = prev.findIndex(x=>x.id===txId);",
      "    if(idx<0) return prev;",
      "    const mine = (winnerOtcId===userId);",
      "    const updated = {...prev[idx], statusGlobal:'escrow', kanbanView: mine ? 'escrow':'lost'};",
      "    const cp = prev.slice(); cp[idx]=updated;",
      "    // si 'lost' oculto en kanban",
      "    return updated.kanbanView==='lost' ? cp.filter(x=>x.id!==txId) : cp;",
      "  });",
      "});",
      "es.addEventListener('tx.completed', (e:any)=>{",
      "  const {txId} = JSON.parse(e.data);",
      "  setItems(prev=>{",
      "    const idx = prev.findIndex(x=>x.id===txId);",
      "    if(idx<0) return prev;",
      "    const updated = {...prev[idx], statusGlobal:'completed', kanbanView:'completed'};",
      "    const cp = prev.slice(); cp[idx]=updated; return cp;",
      "  });",
      "});"
    ],
    "ui_map": [
      "<div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\">",
      "{COLS.map(c=>(",
      "  <section key={c.key} className=\"rounded-xl bg-white shadow p-3\">",
      "    <header className=\"flex items-center justify-between mb-3\">",
      "      <h2 className=\"font-semibold\">{c.title}</h2>",
      "      <span className=\"text-xs text-slate-500\">{items.filter(i=>i.kanbanView===c.key).length} ítems</span>",
      "    </header>",
      "    <ul className=\"space-y-2\">",
      "      {items.filter(i=>i.kanbanView===c.key).map(tx=>(",
      "        <li key={tx.id} className=\"rounded border p-2\">",
      "          <div className=\"text-sm font-medium\">{tx.id}</div>",
      "          <div className=\"text-xs text-slate-500\">{tx.type} · {new Date(tx.createdAt).toLocaleString()}</div>",
      "        </li>",
      "      ))}",
      "    </ul>",
      "  </section>",
      "))}",
      "</div>"
    ]
  },
  "gwt": [
    "Given un CLIENTE crea una tx CTF When se emite tx.created Then aparece en 'Pendientes' para todos los usuarios OTC.",
    "Given un usuario OTC hace una oferta When lista su Kanban Then la tx se ve en 'Con mi oferta' solo para él y sigue en 'Pendientes' para los demás.",
    "Given el CLIENTE acepta una oferta When el ganador visualiza Then ve la tx en 'Escrow creado'; los demás dejan de verla (aparece como perdida en historial).",
    "Given el ganador sube prueba (CTF) y el CLIENTE valida When se completa Then la tx aparece en 'Operación finalizada' para el ganador."
  ],
  "perf": {
    "stores": "Map en memoria; O(1) por búsqueda; sin ORMs",
    "realtime": "SSE ya optimizado con heartbeat cada 25s; filtros cliente ignoran eventos irrelevantes",
    "deps": "sin libs extra"
  },
  "security_min": {
    "auth_headers": "x-user-id/x-role requeridos; en prod usar JWT/Session",
    "access": "Solo CLIENTE dueño puede aceptar/validar; solo OTC ganador sube proof",
    "rate_limit_hint": "aplicar límite en /offer y /accept (no incluido para mantener ligereza)"
  },
  "next_steps": [
    "Pegar los parches del servidor en index.js sobre el simulador existente.",
    "Actualizar el Kanban del front con el mapping de columnas (4) y las suscripciones SSE nuevas.",
    "Mantener filtros de tipo y fecha como ya implementados.",
    "Probar flujo completo: create -> offer (varios) -> accept -> (CTF) proof -> validate -> completed."
  ]
}
